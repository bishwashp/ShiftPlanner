// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Analyst {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  shiftType   String   // AM or PM shift assignment (MORNING, EVENING, WEEKEND)
  employeeType String  @default("employee") // EMPLOYEE, CONTRACTOR
  isActive    Boolean  @default(true)
  customAttributes String? // JSON as string for SQLite compatibility
  skills      String?  // Comma-separated skills for SQLite compatibility
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  preferences AnalystPreference[]
  schedules   Schedule[]
  vacations   Vacation[]
  constraints SchedulingConstraint[]
  patternContinuity PatternContinuity[]
  absences    Absence[]
  fairnessDebts FairnessDebt[]
  replacementAssignments ReplacementAssignment[] @relation("ReplacementAnalyst")
  originalAssignments    ReplacementAssignment[] @relation("OriginalAnalyst")
  
  // Performance indexes for common queries
  @@index([isActive, shiftType]) // For filtering active analysts by shift
  @@index([employeeType, isActive]) // For filtering by employee type
  @@index([email]) // Already unique, but explicit for performance
  @@index([createdAt]) // For sorting and date-based queries
  @@map("analysts")
}

model AnalystPreference {
  id          String   @id @default(cuid())
  analystId   String
  shiftType   String   // MORNING, EVENING, WEEKEND
  dayOfWeek   String   // MONDAY, TUESDAY, etc.
  preference  String   // PREFERRED, AVAILABLE, UNAVAILABLE
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  analyst     Analyst  @relation(fields: [analystId], references: [id], onDelete: Cascade)
  
  // Performance indexes
  @@index([analystId, shiftType, dayOfWeek]) // For preference lookups
  @@index([shiftType, dayOfWeek]) // For shift-based preference queries
  @@unique([analystId, shiftType, dayOfWeek])
  @@map("analyst_preferences")
}

model Vacation {
  id          String   @id @default(cuid())
  analystId   String
  startDate   DateTime
  endDate     DateTime
  reason      String?
  isApproved  Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  analyst     Analyst  @relation(fields: [analystId], references: [id], onDelete: Cascade)
  
  // Performance indexes for date range queries
  @@index([analystId, startDate, endDate]) // For analyst vacation lookups
  @@index([startDate, endDate, isApproved]) // For date range queries with approval status
  @@index([isApproved]) // For filtering approved vacations
  @@map("vacations")
}

model SchedulingConstraint {
  id          String   @id @default(cuid())
  analystId   String?
  shiftType   String?  // MORNING, EVENING, WEEKEND
  startDate   DateTime
  endDate     DateTime
  constraintType String // BLACKOUT_DATE, MAX_SCREENER_DAYS, etc.
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  analyst     Analyst? @relation(fields: [analystId], references: [id], onDelete: Cascade)
  
  // Performance indexes for constraint queries
  @@index([analystId, startDate, endDate, isActive]) // For analyst constraint lookups
  @@index([startDate, endDate, isActive]) // For date range constraint queries
  @@index([constraintType, isActive]) // For constraint type filtering
  @@map("scheduling_constraints")
}

model Schedule {
  id          String   @id @default(cuid())
  analystId   String
  date        DateTime
  shiftType   String   // MORNING, EVENING, WEEKEND
  isScreener  Boolean  @default(false)  // Whether this analyst is designated as Screener for this shift
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  analyst     Analyst  @relation(fields: [analystId], references: [id], onDelete: Cascade)
  
  // Critical performance indexes for schedule queries
  @@index([date, shiftType]) // For date-based schedule queries (most common)
  @@index([analystId, date]) // For analyst schedule lookups
  @@index([date, isScreener]) // For screener assignment queries
  @@index([analystId, date, shiftType]) // For specific analyst/date/shift queries
  @@index([date]) // For pure date-based queries
  @@unique([analystId, date])
  @@map("schedules")
}

model AlgorithmConfig {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  config      String   // JSON as string for SQLite compatibility
  isActive    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Performance indexes
  @@index([isActive]) // For filtering active algorithms
  @@index([name]) // For algorithm name lookups
  @@map("algorithm_configs")
}

model ScheduleGenerationLog {
  id                String   @id @default(cuid())
  generatedBy       String   @default("admin") // User who generated the schedule
  algorithmType     String   // Algorithm used for generation
  startDate         DateTime // Start date of the generated schedule range
  endDate           DateTime // End date of the generated schedule range
  schedulesGenerated Int     // Number of schedules generated
  conflictsDetected Int     @default(0) // Number of conflicts detected
  fairnessScore     Float?   // Overall fairness score from the generation
  executionTime     Int?     // Execution time in milliseconds
  status            String   @default("SUCCESS") // SUCCESS, FAILED, PARTIAL
  errorMessage      String?  // Error message if generation failed
  metadata          String?  // Additional JSON metadata for future extensibility
  createdAt         DateTime @default(now())
  
  // Performance indexes for dashboard queries
  @@index([createdAt]) // For recent activity queries (most important)
  @@index([generatedBy, createdAt]) // For user-specific activity
  @@index([algorithmType, createdAt]) // For algorithm-specific queries
  @@index([status, createdAt]) // For filtering by success/failure
  @@map("schedule_generation_logs")
}

model PatternContinuity {
  id              String   @id @default(cuid())
  algorithmType   String   // Algorithm type for which this continuity data is stored
  analystId       String   // Analyst this continuity data belongs to
  lastPattern     String   // Last work pattern assigned (e.g., "SUN_THU", "MON_FRI", etc.)
  lastWorkDate    DateTime // Last date the analyst worked
  weekNumber      Int      // Week number in the rotation cycle
  metadata        String?  // Additional pattern-specific data as JSON
  updatedAt       DateTime @updatedAt
  createdAt       DateTime @default(now())
  
  analyst         Analyst  @relation(fields: [analystId], references: [id], onDelete: Cascade)
  
  // Unique constraint to ensure one continuity record per analyst per algorithm
  @@unique([algorithmType, analystId])
  @@index([algorithmType, updatedAt]) // For finding latest continuity data
  @@map("pattern_continuity")
}

model Holiday {
  id          String   @id @default(cuid())
  name        String   // Holiday name (e.g., "New Year's Day", "Christmas")
  date        DateTime // Holiday date (stored in UTC, converted to local timezone)
  timezone    String   @default("America/New_York") // Local timezone for the holiday
  isRecurring Boolean  @default(false) // Whether this holiday repeats annually
  year        Int?     // Specific year (null for recurring holidays)
  description String?  // Optional description
  isActive    Boolean  @default(true) // Whether this holiday affects scheduling
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Performance indexes for date and timezone queries
  @@index([date, timezone, isActive]) // For holiday lookups by date and timezone
  @@index([year, isActive]) // For year-based holiday queries
  @@index([isRecurring, isActive]) // For recurring holiday queries
  @@map("holidays")
}

model Absence {
  id          String   @id @default(cuid())
  analystId   String   // Analyst who is absent
  startDate   DateTime // Start date of absence
  endDate     DateTime // End date of absence
  type        String   // VACATION, SICK_LEAVE, PERSONAL, EMERGENCY, etc.
  reason      String?  // Optional reason for absence
  isApproved  Boolean  @default(true) // Whether the absence is approved
  isPlanned   Boolean  @default(true) // Whether this is a planned absence
  
  // New fields for Phase 1
  isPartialDay      Boolean  @default(false)
  startTime         String?  // HH:MM format
  endTime           String?  // HH:MM format
  fractionalUnits   Float    @default(1.0) // Fairness weight
  excludedHolidayDates String? // JSON array of excluded dates
  workDaysCount     Int      @default(0)
  impactScore       String   @default("LOW") // LOW, MEDIUM, HIGH, CRITICAL
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  analyst     Analyst  @relation(fields: [analystId], references: [id], onDelete: Cascade)
  fairnessDebts FairnessDebt[]
  
  // Performance indexes for absence queries
  @@index([analystId, startDate, endDate]) // For analyst absence lookups
  @@index([startDate, endDate, isApproved]) // For date range queries with approval status
  @@index([type, isApproved]) // For absence type filtering
  @@index([isPlanned, isApproved]) // For planned vs unplanned absence queries
  @@map("absences")
}

model Activity {
  id          String   @id @default(cuid())
  type        String   // Activity type (SCHEDULE_GENERATED, ANALYST_ADDED, etc.)
  category    String   // Category (SCHEDULE, ANALYST, ALGORITHM, ABSENCE, SYSTEM)
  title       String   // User-friendly title for the activity
  description String   // Detailed description of what happened
  performedBy String?  // User who performed the action (null for system actions)
  resourceType String? // Type of resource affected (analyst, schedule, algorithm, etc.)
  resourceId  String?  // ID of the affected resource
  metadata    String?  // Additional JSON metadata for context
  impact      String   @default("LOW") // Impact level: LOW, MEDIUM, HIGH, CRITICAL
  createdAt   DateTime @default(now())
  
  // Performance indexes for activity queries
  @@index([createdAt]) // For recent activity queries (most important)
  @@index([category, createdAt]) // For category-based filtering
  @@index([type, createdAt]) // For type-based filtering
  @@index([performedBy, createdAt]) // For user-specific activities
  @@index([impact, createdAt]) // For impact-based filtering
  @@map("activities")
}

model WorkPattern {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "SUN_THU", "MON_FRI", "TUE_SAT"
  displayName String   // e.g., "Sunday-Thursday", "Monday-Friday"
  days        String   // Comma-separated day numbers: "0,1,2,3,4" (Sunday=0, Saturday=6)
  nextPattern String   // Name of next pattern in rotation sequence
  breakDays   Int      @default(0) // Number of break days after this pattern
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0) // Order in which patterns are cycled
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Performance indexes
  @@index([isActive, sortOrder]) // For active pattern queries in order
  @@index([name, isActive]) // For pattern lookups by name
  @@map("work_patterns")
}

// SQLite doesn't support enums, so we use string constants
// ShiftType: "MORNING", "EVENING", "WEEKEND"
// EmployeeType: "EMPLOYEE", "CONTRACTOR"
// DayOfWeek: "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"
// PreferenceType: "PREFERRED", "AVAILABLE", "UNAVAILABLE"
// ConstraintType: "BLACKOUT_DATE", "MAX_SCREENER_DAYS", "MIN_SCREENER_DAYS", "PREFERRED_SCREENER", "UNAVAILABLE_SCREENER"
// AbsenceType: "VACATION", "SICK_LEAVE", "PERSONAL", "EMERGENCY", "TRAINING", "CONFERENCE"


model SystemEvent {
  id          String   @id @default(cuid())
  eventType   String   // SCHEDULE_CHANGED, CONSTRAINT_CHANGED, HOLIDAY_CHANGED, ALGORITHM_RUN
  entityType  String   // SCHEDULE, CONSTRAINT, HOLIDAY, ANALYST
  entityId    String?
  
  action      String   // CREATED, UPDATED, DELETED
  actorType   String   // USER, SYSTEM, ALGORITHM
  actorId     String?
  
  before      String?  // JSON string
  after       String?  // JSON string
  changes     String?  // JSON string
  
  metadata    String?  // JSON string
  
  createdAt   DateTime @default(now())
  
  // Performance indexes
  @@index([eventType, createdAt])
  @@index([entityType, entityId])
  @@map("system_events")
}

model FairnessDebt {
  id          String   @id @default(cuid())
  analystId   String
  absenceId   String?  // Link to absence that caused debt
  debtAmount  Float    // Weighted workload units missed
  reason      String   // "ABSENCE_COVERAGE", "WEEKEND_MISS", etc.
  createdAt   DateTime @default(now())
  resolvedAt  DateTime? // When debt was repaid
  
  analyst     Analyst  @relation(fields: [analystId], references: [id], onDelete: Cascade)
  absence     Absence? @relation(fields: [absenceId], references: [id])
  
  @@index([analystId, resolvedAt]) // For active debt queries
  @@map("fairness_debts")
}

model ReplacementAssignment {
  id                   String   @id @default(cuid())
  originalAnalystId    String
  replacementAnalystId String
  date                 DateTime
  shiftType            String   // MORNING, EVENING, WEEKEND
  status               String   // ACTIVE, REASSIGNED, CANCELLED
  reassignmentChain    String?  // JSON array of analyst IDs: ["A", "B", "C"]
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  originalAnalyst      Analyst  @relation("OriginalAnalyst", fields: [originalAnalystId], references: [id], onDelete: Cascade)
  replacementAnalyst   Analyst  @relation("ReplacementAnalyst", fields: [replacementAnalystId], references: [id], onDelete: Cascade)
  
  @@index([date, status])
  @@index([originalAnalystId])
  @@index([replacementAnalystId])
  @@map("replacement_assignments")
}
