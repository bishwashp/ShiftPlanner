/**
 * Script to generate and apply schedules
 * 
 * Usage:
 * npx ts-node scripts/generate-schedules.ts [options]
 * 
 * Options:
 * --start-date <date>: Start date for generation (YYYY-MM-DD format)
 * --end-date <date>: End date for generation (YYYY-MM-DD format)
 * --algorithm <type>: Algorithm type (default: weekend-rotation)
 * --clear: Clear existing schedules before generating
 * --dry-run: Generate but don't save to database
 * --help: Show usage information
 */

import { prisma } from '../src/lib/prisma';
import { WeekendRotationAlgorithm } from '../src/services/scheduling/algorithms/WeekendRotationAlgorithm';
import { createLocalDate } from '../src/utils/dateUtils';
import { clearSchedules } from './clear-schedules';
import { scheduleGenerationLogger } from '../src/services/ScheduleGenerationLogger';

interface GenerateOptions {
  startDate: Date;
  endDate: Date;
  algorithmType: string;
  clearExisting: boolean;
  dryRun: boolean;
  generatedBy: string;
}

async function generateSchedules(options: GenerateOptions) {
  const startTime = Date.now();
  console.log('üîÑ Generating schedules...');
  console.log(`üìÖ Date range: ${options.startDate.toISOString().split('T')[0]} to ${options.endDate.toISOString().split('T')[0]}`);
  console.log(`üîÑ Algorithm: ${options.algorithmType}`);
  console.log(`üë§ Generated by: ${options.generatedBy}`);
  
  try {
    // Clear existing schedules if requested
    if (options.clearExisting) {
      console.log('üßπ Clearing existing schedules...');
      await clearSchedules({
        keepContinuity: false,
        startDate: options.startDate,
        endDate: options.endDate
      });
    }
    
    // Create algorithm instance
    const algorithm = new WeekendRotationAlgorithm();
    
    // Get analysts from database
    const analysts = await prisma.analyst.findMany({
      where: { isActive: true },
      include: {
        vacations: { where: { isApproved: true } },
        constraints: { where: { isActive: true } }
      }
    });
    
    console.log(`üë• Found ${analysts.length} active analysts`);
    
    // Get existing schedules
    const existingSchedules = await prisma.schedule.findMany({
      where: {
        date: {
          gte: new Date(options.startDate.getTime() - 14 * 24 * 60 * 60 * 1000), // 2 weeks before
          lte: options.endDate
        }
      }
    });
    
    console.log(`üìã Found ${existingSchedules.length} existing schedules`);
    
    // Get global constraints
    const globalConstraints = await prisma.schedulingConstraint.findMany({
      where: {
        analystId: null,
        isActive: true,
        OR: [
          { startDate: { lte: options.endDate }, endDate: { gte: options.startDate } }
        ]
      }
    });
    
    console.log(`üîí Found ${globalConstraints.length} global constraints`);
    
    // Generate schedules
    console.log('üîÑ Generating schedules...');
    const result = await algorithm.generateSchedules({
      startDate: options.startDate,
      endDate: options.endDate,
      analysts,
      existingSchedules,
      globalConstraints,
      algorithmConfig: {
        optimizationStrategy: 'HILL_CLIMBING',
        maxIterations: 1000,
        convergenceThreshold: 0.001,
        fairnessWeight: 0.4,
        efficiencyWeight: 0.3,
        constraintWeight: 0.3,
        randomizationFactor: 0.1,
        screenerAssignmentStrategy: 'WORKLOAD_BALANCE',
        weekendRotationStrategy: 'FAIRNESS_OPTIMIZED'
      }
    });
    
    // Analyze results
    console.log(`‚úÖ Generated ${result.proposedSchedules.length} proposed schedules`);
    console.log(`‚ö†Ô∏è Found ${result.conflicts.length} conflicts`);
    console.log(`üîÑ Found ${result.overwrites.length} overwrites`);
    
    // Save schedules to database if not dry run
    if (!options.dryRun) {
      console.log('üíæ Saving schedules to database...');
      
      // First, delete any existing schedules in the date range
      await prisma.schedule.deleteMany({
        where: {
          date: {
            gte: options.startDate,
            lte: options.endDate
          }
        }
      });
      
      // Then create new schedules
      const schedules = result.proposedSchedules.map((schedule: any) => ({
        analystId: schedule.analystId,
        date: createLocalDate(schedule.date),
        shiftType: schedule.shiftType,
        isScreener: schedule.isScreener
      }));
      
      const savedCount = await prisma.schedule.createMany({
        data: schedules
      });
      
      console.log(`‚úÖ Saved ${savedCount.count} schedules to database`);
      
      // Log the successful generation
      const executionTime = Date.now() - startTime;
      await scheduleGenerationLogger.logSuccess({
        generatedBy: options.generatedBy,
        algorithmType: options.algorithmType,
        startDate: options.startDate,
        endDate: options.endDate,
        schedulesGenerated: savedCount.count,
        conflictsDetected: result.conflicts.length,
        fairnessScore: result.fairnessMetrics?.overallFairnessScore || 0,
        executionTime,
        metadata: JSON.stringify({
          optimizationStrategy: 'HILL_CLIMBING',
          analysts: analysts.length
        })
      });
    } else {
      console.log('üîç Dry run - schedules not saved to database');
    }
    
  } catch (error) {
    console.error('‚ùå Generation failed:', error);
    
    // Log the failed generation
    const executionTime = Date.now() - startTime;
    await scheduleGenerationLogger.logFailure({
      generatedBy: options.generatedBy,
      algorithmType: options.algorithmType,
      startDate: options.startDate,
      endDate: options.endDate,
      executionTime,
      errorMessage: error instanceof Error ? error.message : 'Unknown error',
      metadata: JSON.stringify({
        error: error instanceof Error ? error.stack : String(error)
      })
    });
  } finally {
    await prisma.$disconnect();
    console.log('üîå Database disconnected');
  }
}

// Parse command line arguments
function parseArgs(): GenerateOptions {
  const args = process.argv.slice(2);
  const options: GenerateOptions = {
    startDate: createLocalDate('2025-10-05'),
    endDate: createLocalDate('2025-11-01'),
    algorithmType: 'weekend-rotation',
    clearExisting: false,
    dryRun: false,
    generatedBy: 'script'
  };
  
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--help':
        console.log(`
Usage: npx ts-node scripts/generate-schedules.ts [options]

Options:
  --start-date <date>   Start date for generation (YYYY-MM-DD format)
  --end-date <date>     End date for generation (YYYY-MM-DD format)
  --algorithm <type>    Algorithm type (default: weekend-rotation)
  --clear               Clear existing schedules before generating
  --dry-run             Generate but don't save to database
  --generated-by <user> User who generated the schedules (default: script)
  --help                Show this help message
        `);
        process.exit(0);
        break;
        
      case '--start-date':
        if (i + 1 < args.length) {
          try {
            options.startDate = createLocalDate(args[i + 1]);
            i++;
          } catch (e) {
            console.error('‚ùå Invalid date format. Use YYYY-MM-DD');
            process.exit(1);
          }
        } else {
          console.error('‚ùå --start-date requires an argument');
          process.exit(1);
        }
        break;
        
      case '--end-date':
        if (i + 1 < args.length) {
          try {
            options.endDate = createLocalDate(args[i + 1]);
            i++;
          } catch (e) {
            console.error('‚ùå Invalid date format. Use YYYY-MM-DD');
            process.exit(1);
          }
        } else {
          console.error('‚ùå --end-date requires an argument');
          process.exit(1);
        }
        break;
        
      case '--algorithm':
        if (i + 1 < args.length) {
          options.algorithmType = args[i + 1];
          i++;
        } else {
          console.error('‚ùå --algorithm requires an argument');
          process.exit(1);
        }
        break;
        
      case '--clear':
        options.clearExisting = true;
        break;
        
      case '--dry-run':
        options.dryRun = true;
        break;
        
      case '--generated-by':
        if (i + 1 < args.length) {
          options.generatedBy = args[i + 1];
          i++;
        } else {
          console.error('‚ùå --generated-by requires an argument');
          process.exit(1);
        }
        break;
        
      default:
        console.error(`‚ùå Unknown option: ${args[i]}`);
        console.log('Use --help for usage information');
        process.exit(1);
    }
  }
  
  return options;
}

// Run the function
if (require.main === module) {
  const options = parseArgs();
  generateSchedules(options)
    .then(() => console.log('‚úÖ Operation completed'))
    .catch(e => console.error('‚ùå Operation failed:', e));
}

export { generateSchedules };
