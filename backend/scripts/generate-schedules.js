"use strict";
/**
 * Script to generate and apply schedules
 *
 * Usage:
 * npx ts-node scripts/generate-schedules.ts [options]
 *
 * Options:
 * --start-date <date>: Start date for generation (YYYY-MM-DD format)
 * --end-date <date>: End date for generation (YYYY-MM-DD format)
 * --algorithm <type>: Algorithm type (default: weekend-rotation)
 * --clear: Clear existing schedules before generating
 * --dry-run: Generate but don't save to database
 * --help: Show usage information
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSchedules = generateSchedules;
const prisma_1 = require("../src/lib/prisma");
const WeekendRotationAlgorithm_1 = require("../src/services/scheduling/algorithms/WeekendRotationAlgorithm");
const dateUtils_1 = require("../src/utils/dateUtils");
const clear_schedules_1 = require("./clear-schedules");
const ScheduleGenerationLogger_1 = require("../src/services/ScheduleGenerationLogger");
function generateSchedules(options) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const startTime = Date.now();
        console.log('üîÑ Generating schedules...');
        console.log(`üìÖ Date range: ${options.startDate.toISOString().split('T')[0]} to ${options.endDate.toISOString().split('T')[0]}`);
        console.log(`üîÑ Algorithm: ${options.algorithmType}`);
        console.log(`üë§ Generated by: ${options.generatedBy}`);
        try {
            // Clear existing schedules if requested
            if (options.clearExisting) {
                console.log('üßπ Clearing existing schedules...');
                yield (0, clear_schedules_1.clearSchedules)({
                    keepContinuity: false,
                    startDate: options.startDate,
                    endDate: options.endDate
                });
            }
            // Create algorithm instance
            const algorithm = new WeekendRotationAlgorithm_1.WeekendRotationAlgorithm();
            // Get analysts from database
            const analysts = yield prisma_1.prisma.analyst.findMany({
                where: { isActive: true },
                include: {
                    vacations: { where: { isApproved: true } },
                    constraints: { where: { isActive: true } }
                }
            });
            console.log(`üë• Found ${analysts.length} active analysts`);
            // Get existing schedules
            const existingSchedules = yield prisma_1.prisma.schedule.findMany({
                where: {
                    date: {
                        gte: new Date(options.startDate.getTime() - 14 * 24 * 60 * 60 * 1000), // 2 weeks before
                        lte: options.endDate
                    }
                }
            });
            console.log(`üìã Found ${existingSchedules.length} existing schedules`);
            // Get global constraints
            const globalConstraints = yield prisma_1.prisma.schedulingConstraint.findMany({
                where: {
                    analystId: null,
                    isActive: true,
                    OR: [
                        { startDate: { lte: options.endDate }, endDate: { gte: options.startDate } }
                    ]
                }
            });
            console.log(`üîí Found ${globalConstraints.length} global constraints`);
            // Generate schedules
            console.log('üîÑ Generating schedules...');
            const result = yield algorithm.generateSchedules({
                startDate: options.startDate,
                endDate: options.endDate,
                analysts,
                existingSchedules,
                globalConstraints,
                algorithmConfig: {
                    optimizationStrategy: 'HILL_CLIMBING',
                    maxIterations: 1000,
                    convergenceThreshold: 0.001,
                    fairnessWeight: 0.4,
                    efficiencyWeight: 0.3,
                    constraintWeight: 0.3,
                    randomizationFactor: 0.1,
                    screenerAssignmentStrategy: 'WORKLOAD_BALANCE',
                    weekendRotationStrategy: 'FAIRNESS_OPTIMIZED'
                }
            });
            // Analyze results
            console.log(`‚úÖ Generated ${result.proposedSchedules.length} proposed schedules`);
            console.log(`‚ö†Ô∏è Found ${result.conflicts.length} conflicts`);
            console.log(`üîÑ Found ${result.overwrites.length} overwrites`);
            // Save schedules to database if not dry run
            if (!options.dryRun) {
                console.log('üíæ Saving schedules to database...');
                // First, delete any existing schedules in the date range
                yield prisma_1.prisma.schedule.deleteMany({
                    where: {
                        date: {
                            gte: options.startDate,
                            lte: options.endDate
                        }
                    }
                });
                // Then create new schedules
                const schedules = result.proposedSchedules.map((schedule) => ({
                    analystId: schedule.analystId,
                    date: (0, dateUtils_1.createLocalDate)(schedule.date),
                    shiftType: schedule.shiftType,
                    isScreener: schedule.isScreener
                }));
                const savedCount = yield prisma_1.prisma.schedule.createMany({
                    data: schedules
                });
                console.log(`‚úÖ Saved ${savedCount.count} schedules to database`);
                // Log the successful generation
                const executionTime = Date.now() - startTime;
                yield ScheduleGenerationLogger_1.scheduleGenerationLogger.logSuccess({
                    generatedBy: options.generatedBy,
                    algorithmType: options.algorithmType,
                    startDate: options.startDate,
                    endDate: options.endDate,
                    schedulesGenerated: savedCount.count,
                    conflictsDetected: result.conflicts.length,
                    fairnessScore: ((_a = result.fairnessMetrics) === null || _a === void 0 ? void 0 : _a.overallFairnessScore) || 0,
                    executionTime,
                    metadata: JSON.stringify({
                        optimizationStrategy: 'HILL_CLIMBING',
                        analysts: analysts.length
                    })
                });
            }
            else {
                console.log('üîç Dry run - schedules not saved to database');
            }
        }
        catch (error) {
            console.error('‚ùå Generation failed:', error);
            // Log the failed generation
            const executionTime = Date.now() - startTime;
            yield ScheduleGenerationLogger_1.scheduleGenerationLogger.logFailure({
                generatedBy: options.generatedBy,
                algorithmType: options.algorithmType,
                startDate: options.startDate,
                endDate: options.endDate,
                executionTime,
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
                metadata: JSON.stringify({
                    error: error instanceof Error ? error.stack : String(error)
                })
            });
        }
        finally {
            yield prisma_1.prisma.$disconnect();
            console.log('üîå Database disconnected');
        }
    });
}
// Parse command line arguments
function parseArgs() {
    const args = process.argv.slice(2);
    const options = {
        startDate: (0, dateUtils_1.createLocalDate)('2025-10-05'),
        endDate: (0, dateUtils_1.createLocalDate)('2025-11-01'),
        algorithmType: 'weekend-rotation',
        clearExisting: false,
        dryRun: false,
        generatedBy: 'script'
    };
    for (let i = 0; i < args.length; i++) {
        switch (args[i]) {
            case '--help':
                console.log(`
Usage: npx ts-node scripts/generate-schedules.ts [options]

Options:
  --start-date <date>   Start date for generation (YYYY-MM-DD format)
  --end-date <date>     End date for generation (YYYY-MM-DD format)
  --algorithm <type>    Algorithm type (default: weekend-rotation)
  --clear               Clear existing schedules before generating
  --dry-run             Generate but don't save to database
  --generated-by <user> User who generated the schedules (default: script)
  --help                Show this help message
        `);
                process.exit(0);
                break;
            case '--start-date':
                if (i + 1 < args.length) {
                    try {
                        options.startDate = (0, dateUtils_1.createLocalDate)(args[i + 1]);
                        i++;
                    }
                    catch (e) {
                        console.error('‚ùå Invalid date format. Use YYYY-MM-DD');
                        process.exit(1);
                    }
                }
                else {
                    console.error('‚ùå --start-date requires an argument');
                    process.exit(1);
                }
                break;
            case '--end-date':
                if (i + 1 < args.length) {
                    try {
                        options.endDate = (0, dateUtils_1.createLocalDate)(args[i + 1]);
                        i++;
                    }
                    catch (e) {
                        console.error('‚ùå Invalid date format. Use YYYY-MM-DD');
                        process.exit(1);
                    }
                }
                else {
                    console.error('‚ùå --end-date requires an argument');
                    process.exit(1);
                }
                break;
            case '--algorithm':
                if (i + 1 < args.length) {
                    options.algorithmType = args[i + 1];
                    i++;
                }
                else {
                    console.error('‚ùå --algorithm requires an argument');
                    process.exit(1);
                }
                break;
            case '--clear':
                options.clearExisting = true;
                break;
            case '--dry-run':
                options.dryRun = true;
                break;
            case '--generated-by':
                if (i + 1 < args.length) {
                    options.generatedBy = args[i + 1];
                    i++;
                }
                else {
                    console.error('‚ùå --generated-by requires an argument');
                    process.exit(1);
                }
                break;
            default:
                console.error(`‚ùå Unknown option: ${args[i]}`);
                console.log('Use --help for usage information');
                process.exit(1);
        }
    }
    return options;
}
// Run the function
if (require.main === module) {
    const options = parseArgs();
    generateSchedules(options)
        .then(() => console.log('‚úÖ Operation completed'))
        .catch(e => console.error('‚ùå Operation failed:', e));
}
//# sourceMappingURL=generate-schedules.js.map