import { EventType, CalendarEvent } from '../../generated/prisma';

export interface ConstraintConfiguration {
  minimumCoverage?: {
    or?: Array<{
      employeeType?: string;
      experienceLevel?: string;
      count: number;
      and?: Array<{
        employeeType?: string;
        experienceLevel?: string;
        count: number;
      }>;
    }>;
    and?: Array<{
      employeeType?: string;
      experienceLevel?: string;
      count: number;
    }>;
    employeeType?: string;
    experienceLevel?: string;
    count?: number;
  };
  additionalScreeners?: number;
  reduceScreeners?: boolean;
  informational?: boolean;
  noAdditionalConstraints?: boolean;
}

export interface EventConstraint {
  source: 'EVENT';
  priority: number;
  constraints: ConstraintConfiguration;
  eventId: string;
  eventTitle: string;
  dateRange: {
    start: Date;
    end: Date;
  };
}

export class EventConstraintGenerator {
  
  /**
   * Generate default constraints based on event type
   */
  generateDefaultConstraints(eventType: EventType): ConstraintConfiguration {
    switch (eventType) {
      case 'MAJOR_RELEASE':
        return {
          minimumCoverage: {
            or: [
              { employeeType: 'FULL_TIME', count: 1 },
              { 
                experienceLevel: 'SENIOR',
                employeeType: 'CONSULTANT',
                count: 1
              }
            ]
          },
          additionalScreeners: 1 // Extra screener for major events
        };
        
      case 'MINOR_RELEASE':
        return {
          minimumCoverage: {
            or: [
              { experienceLevel: 'SENIOR', count: 1 },
              { experienceLevel: 'EXPERT', count: 1 }
            ]
          }
        };
        
      case 'PARTNER_DOWNTIME':
        return {
          informational: true, // Just shows on calendar, no constraints
          reduceScreeners: true // Maybe fewer screeners needed during downtime
        };
        
      case 'HOLIDAY':
        return {
          noAdditionalConstraints: true
        };
    }
  }

  /**
   * Generate event constraints for a specific date
   */
  generateEventConstraints(events: CalendarEvent[]): EventConstraint[] {
    return events.map(event => {
      // Use override if available, otherwise use defaults
      const constraints = event.overrideConstraints || event.defaultConstraints;
      
      return {
        source: 'EVENT',
        priority: this.getEventPriority(event.eventType),
        constraints: constraints as ConstraintConfiguration,
        eventId: event.id,
        eventTitle: event.title,
        dateRange: {
          start: event.startDate,
          end: event.endDate
        }
      };
    });
  }

  /**
   * Create a calendar event with auto-generated constraints
   */
  async createEventWithConstraints(
    title: string,
    startDate: Date,
    endDate: Date,
    eventType: EventType,
    calendarType: any,
    description?: string,
    overrideConstraints?: ConstraintConfiguration
  ): Promise<CalendarEvent> {
    
    const defaultConstraints = this.generateDefaultConstraints(eventType);
    
    return {
      id: '', // Will be generated by Prisma
      title,
      startDate,
      endDate,
      eventType,
      calendarType,
      description: description || null,
      defaultConstraints: defaultConstraints as any,
      overrideConstraints: overrideConstraints as any || null,
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  /**
   * Get priority for event types (lower number = higher priority)
   */
  private getEventPriority(eventType: EventType): number {
    switch (eventType) {
      case 'MAJOR_RELEASE': return 1; // Highest priority
      case 'MINOR_RELEASE': return 2;
      case 'PARTNER_DOWNTIME': return 3;
      case 'HOLIDAY': return 4; // Lowest priority
    }
  }

  /**
   * Validate constraint configuration
   */
  validateConstraints(constraints: ConstraintConfiguration): boolean {
    if (constraints.noAdditionalConstraints) return true;
    if (constraints.informational) return true;
    
    if (constraints.minimumCoverage) {
      // Validate that coverage requirements make sense
      if (constraints.minimumCoverage.or) {
        return constraints.minimumCoverage.or.every(req => req.count > 0);
      }
      if (constraints.minimumCoverage.and) {
        return constraints.minimumCoverage.and.every(req => req.count > 0);
      }
      if (constraints.minimumCoverage.count) {
        return constraints.minimumCoverage.count > 0;
      }
    }
    
    return true;
  }

  /**
   * Merge multiple event constraints for the same date
   */
  mergeEventConstraints(constraints: EventConstraint[]): EventConstraint {
    if (constraints.length === 0) {
      throw new Error('Cannot merge empty constraints array');
    }
    
    if (constraints.length === 1) {
      return constraints[0];
    }
    
    // Sort by priority (lowest number = highest priority)
    const sorted = constraints.sort((a, b) => a.priority - b.priority);
    
    // Use highest priority constraint as base, merge others
    const primary = sorted[0];
    const merged: EventConstraint = {
      ...primary,
      eventTitle: sorted.map(c => c.eventTitle).join(' + '),
      constraints: this.mergeConstraintConfigurations(sorted.map(c => c.constraints))
    };
    
    return merged;
  }

  /**
   * Merge multiple constraint configurations
   */
  private mergeConstraintConfigurations(configs: ConstraintConfiguration[]): ConstraintConfiguration {
    const merged: ConstraintConfiguration = {};
    
    // Take the most restrictive constraints
    let maxAdditionalScreeners = 0;
    let hasReduceScreeners = false;
    let isInformational = true;
    
    for (const config of configs) {
      if (config.additionalScreeners) {
        maxAdditionalScreeners = Math.max(maxAdditionalScreeners, config.additionalScreeners);
      }
      if (config.reduceScreeners) {
        hasReduceScreeners = true;
      }
      if (!config.informational && !config.noAdditionalConstraints) {
        isInformational = false;
      }
      if (config.minimumCoverage && !merged.minimumCoverage) {
        merged.minimumCoverage = config.minimumCoverage;
      }
    }
    
    if (maxAdditionalScreeners > 0) {
      merged.additionalScreeners = maxAdditionalScreeners;
    }
    if (hasReduceScreeners && isInformational) {
      merged.reduceScreeners = true;
    }
    if (isInformational && !merged.minimumCoverage) {
      merged.informational = true;
    }
    
    return merged;
  }
}

// Export singleton instance
export const eventConstraintGenerator = new EventConstraintGenerator();